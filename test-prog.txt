; The program reads input 1 character at a time pushing digits into the stack and performing operations when it encounters +, -, *, /, or ^.
; Whenever an operatoe is encountered two values are popped and the result is computed using subroutines and pushes it back. Multiplication
; and division are performed by using repeated addition and subtracion and exponentiation calls the multiply subroutine repeatedly. When the
; user inputs '=' the program verifies theres one value left on the stack and prints it in hex otherwise it outputs "Invalid Expression".
; When underflow occurs the same error appears which handles malformed expressions like having too few operands
.ORIG x3000
AND R0, R0, #0 ; Clear all registers
AND R1, R1, #0
AND R2, R2, #0
AND R3, R3, #0
AND R4, R4, #0
AND R5, R5, #0
AND R6, R6, #0
JSR EVALUATE ; Start calculator
HALT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;R3- value to print in hexadecimal
PRINT_HEX
	ST R0, HEX_SaveR0 ; Save registers
	ST R1, HEX_SaveR1
	ST R2, HEX_SaveR2
	ST R3, HEX_SaveR3
	ST R4, HEX_SaveR4
	ST R5, HEX_SaveR5
	ST R6, HEX_SaveR6
        ST R7, HEX_SaveR7
	ADD R3, R5, #0
	AND R2, R2, #0    ; digit counter = 0
TOP_LOOP
	ADD R4, R2, #-4   ; R4 = digit counter - 4
	BRzp DONE        ; if >= 4, we're done
	AND R0, R0, #0   ; digit = 0
	AND R1, R1, #0   ; bit counter = 0
INNER_LOOP
	ADD R4, R1, #-4  ; R4 = bit counter - 4
        BRzp CONVERT    ; if >= 4, go convert to ASCII
        ADD R0, R0, R0 ; multiply R0 by 2
        ADD R3, R3, #0 ; set cond code based on R3
        BRn ADD_ONE	; if R3 is negative MSB is 1
        BRnzp SHIFT_LEFT
        ADD_ONE
        	ADD R0, R0, #1 ; add 1 to digit MSB was 1
SHIFT_LEFT
        ADD R3, R3, R3 ; shift R3 left to move to next bit
        ADD R1, R1, #1 ; increment bit counter
        BRnzp INNER_LOOP
CONVERT
        ADD R0, R0, #-9 ; check if digit is greater than 9
        BRp ADD_A	; if positive its A-F
        ADD R0, R0 , #9 ; restore digit
        LD R5, ASCII_ZERO
        ADD R0, R0, R5 ; convert to ascii 0-9
        BRnzp PRINT_INC_DIGIT_COUNTER
ADD_A
        ADD R0, R0, #9 ; restore digit
        LD R5, ASCII_A
        ADD R0, R0, R5 ; convert to ascii A-F
PRINT_INC_DIGIT_COUNTER
        OUT		; print character
        ADD R2, R2, #1  ; increment digit counter
        BRnzp TOP_LOOP  ; process next digit
DONE
        LD R0, HEX_SaveR0 ; restore all registers 
	LD R1, HEX_SaveR1
	LD R2, HEX_SaveR2
	LD R3, HEX_SaveR3
	LD R4, HEX_SaveR4
	LD R5, HEX_SaveR5
	LD R6, HEX_SaveR6
	LD R7, HEX_SaveR7
	RET
	ASCII_ZERO    .FILL x30    ; '0'
	ASCII_A    .FILL x37    ; 'A' - 10
	HEX_SaveR0 .BLKW #1
	HEX_SaveR1 .BLKW #1
        HEX_SaveR2 .BLKW #1
        HEX_SaveR3 .BLKW #1
        HEX_SaveR4 .BLKW #1
        HEX_SaveR5 .BLKW #1
        HEX_SaveR6 .BLKW #1
	HEX_SaveR7 .BLKW #1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;R0 - character input from keyboard
;R6 - current numerical output
;
;
EVALUATE
	ST R7, EVAL_SaveR7 ; save return address ; save return address
GET_INPUT_LOOP
	GETC ; read user input
	OUT  ; echo character to screen
	; is_equal
	LD R1, ASCII_EQUALS ; load '='
	NOT R1, R1 ; invert hex for =
	ADD R1, R1, #1 ; add 1
	ADD R1, R0, R1 ; add to current char to see if it matches
	BRz DONE_EVAL ; if = sign was inputted go to done_eval

	; is_space loop
       	LD R1, ASCII_SPACE ; load ' '
       	NOT R1, R1 ; invert hex for space char
       	ADD R1, R1, #1 ; add 1
       	ADD R1, R0, R1 ; add to current char to see if it matches
       	BRz GET_INPUT_LOOP ; if it matches return to top of loop

	; is_zero_to_nine loop
       	LD R1, ASCII_ZERO_NEG ; load '-48'
	ADD R1, R0, R1 ; add negative 48 to see if it is greater than ascii 0

       	BRn NOT_A_DIGIT ; if it is less than ascii 0 then go to not a digit
	ADD R1, R1, #-9 ; if it is greater than ascii 0 subtract 9 to see if it is  still greater than 0 because if it is then its greater than ascii 9 meaning its not a digit
	BRp NOT_A_DIGIT
	LD R1, ASCII_ZERO_NEG ; load '-48'
	ADD R0, R0, R1 ; R0 - 48 gives numeric value
	JSR PUSH ; push number to stack
	BRnzp GET_INPUT_LOOP ; get next input
NOT_A_DIGIT
	; addition check
        LD R1, ASCII_PLUS ; load '+'
        NOT R1, R1
        ADD R1, R1, #1
        ADD R1, R0, R1
        BRz DO_PLUS

	; minus check
        LD R1, ASCII_MINUS ; load '-'
        NOT R1, R1
        ADD R1, R1, #1
        ADD R1, R0, R1
	BRz DO_MIN

	; multiplication check
	LD R1, ASCII_MULT ; load '*'
        NOT R1, R1
        ADD R1, R1, #1
        ADD R1, R0, R1
        BRz DO_MUL

	; division check
        LD R1, ASCII_DIV ; load '/'
        NOT R1, R1
        ADD R1, R1, #1
        ADD R1, R0, R1
	BRz DO_DIV

	; exponent check
        LD R1, ASCII_EXP ; load '^'
        NOT R1, R1
        ADD R1, R1, #1
        ADD R1, R0, R1
        BRz DO_EXP
        BRnp PRINT_INVALID

DO_PLUS
	JSR POP ; pop first operand
	ADD R5, R5, #0 ; set condition code for R5
	BRp PRINT_INVALID ; if R5=1 underflow occurred
	ADD R4, R0, #0 ; R4 = first operand

	JSR POP ; pop second operand
	ADD R5, R5, #0
	BRp PRINT_INVALID
	ADD R3, R0, #0 ; R3 = second operand

	JSR PLUS ; R0 = R3 + R4
	JSR PUSH ; push result
	BRnzp GET_INPUT_LOOP

DO_MIN
	JSR POP
       	ADD R5, R5, #0
       	BRp PRINT_INVALID
       	ADD R4, R0, #0

       	JSR POP
       	ADD R5, R5, #0
       	BRp PRINT_INVALID
       	ADD R3, R0, #0

       	JSR MIN ; R0 = R3 - R4
       	JSR PUSH
       	BRnzp GET_INPUT_LOOP
DO_MUL
	JSR POP
       	ADD R5, R5, #0
       	BRp PRINT_INVALID
       	ADD R4, R0, #0

       	JSR POP
       	ADD R5, R5, #0
       	BRp PRINT_INVALID
       	ADD R3, R0, #0

       	JSR MUL ; R0 = R3 * R4
       	JSR PUSH
       	BRnzp GET_INPUT_LOOP
DO_DIV
	JSR POP
       	ADD R5, R5, #0
       	BRp PRINT_INVALID
       	ADD R4, R0, #0

       	JSR POP
       	ADD R5, R5, #0
       	BRp PRINT_INVALID
       	ADD R3, R0, #0

       	JSR DIV ; R0 = R3 / R4
       	JSR PUSH
       	BRnzp GET_INPUT_LOOP
DO_EXP
	JSR POP
        ADD R5, R5, #0
        BRp PRINT_INVALID
        ADD R4, R0, #0 ; R4 = exponent

        JSR POP
        ADD R5, R5, #0
        BRp PRINT_INVALID
        ADD R3, R0, #0 ; R0 = R3 ^ R4

        JSR EXP
        JSR PUSH
        BRnzp GET_INPUT_LOOP
DONE_EVAL
	LD R1, EVAL_STACK_START ; R1 = x4000 (bottom of stack)
	LDI R2, EVAL_STACK_TOP_PTR ; R2 = current stack top pointer
	NOT R2, R2
	ADD R2, R2, #1 ; R2 = -STACK_TOP
	ADD R1, R1, R2 ; R1 = STACK_START - STACK_TOP = item count
	ADD R1, R1, #-1 ; R1 = item count - 1
	BRnp PRINT_INVALID ; if not zero, not exactly 1 item
VALID
        JSR POP ; pop final result
        ADD R5, R0, #0    ; store result in R5
        JSR PRINT_HEX	; print result in hex
        HALT
PRINT_INVALID
	LEA R0, INVALID_MESSAGE ; load address of error message
	PUTS ; print string
	HALT
;your code goes here
EVAL_SaveR7 .BLKW #1

ASCII_EQUALS .FILL x3D
ASCII_SPACE .FILL x20
ASCII_ZERO_NEG .FILL xFFD0    ; -48
ASCII_PLUS .FILL x2B
ASCII_MINUS .FILL x2D
ASCII_MULT .FILL x2A
ASCII_DIV .FILL x2F
ASCII_EXP .FILL x5E
EVAL_STACK_START .FILL x4000
EVAL_STACK_TOP_PTR .FILL STACK_TOP
INVALID_MESSAGE .STRINGZ "Invalid Expression"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
PLUS	
;your code goes here
	ADD R0, R3, R4 ; R0 = R3 + R4
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
MIN	
;your code goes here
	NOT R4, R4 ; invert R4
	ADD R4, R4, #1 ; R4 = -R4 (twos comp)
	ADD R0, R3, R4 ; R0 = R3 - R4
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
MUL	
	AND R0, R0, #0 ; R0 = 0 (accumulator)
	ADD R4, R4, #0       ; set cond code for R4
    	BRz MUL_DONE         ; if R4 =  0, result = 0
    	BRp MUL_LOOP         ; if R4 > 0, go to loop
    	; R4 is negative: negate R3 and R4
    	NOT R3, R3
    	ADD R3, R3, #1       ; R3 = -R3
    	NOT R4, R4
    	ADD R4, R4, #1       ; R4 = -R4
;your code goes here
MUL_LOOP
	ADD R0, R0, R3 ; R0 = R0 + R3
	ADD R4, R4, #-1 ; decrement counter
	BRp MUL_LOOP ; loop while R4 > 0
MUL_DONE
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
DIV	
;your code goes here
        AND R0, R0, #0 ; R0 = 0
	NOT R4, R4
	ADD R4, R4, #1 ; R4 = -R4
;your code goes here
DIV_LOOP
        ADD R3, R3, R4 ; R3 = R3 - R4
	BRzp INC_QUO ; if R3 >= 0 increment quotient
        RET	
INC_QUO
	ADD R0, R0, #1 ; increment quotient
	AND R3, R3, R3 ; set cond code for R3
	BRp DIV_LOOP ; if R3 > 0 continue dividing loop
	RET
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
EXP
;your code goes here
	ST R3, EXP_SaveBase ; save base
	ST R7, EXP_SaveR7 ; save return address
	AND R2, R2, #0
	ADD R2, R2, R4 ; R2 = exponent
	AND R3, R3, #0
	ADD R3, R3, #1 ; R3 = 1
;your code goes here
EXP_LOOP
	LD R4, EXP_SaveBase ; R4 = base
	JSR MUL ; R0 = R3 * R4
	ADD R3, R0, #0 ; R3 = new result
        ADD R2, R2, #-1 ; decrement exponent counter
        BRp EXP_LOOP ; loop whie counter >0
	ADD R0, R3, #0
	LD R7, EXP_SaveR7 ; restore return address
        RET


EXP_SaveR4  .BLKW #1
EXP_SaveR7  .BLKW #1
EXP_SaveBase .BLKW #1
;IN:R0, OUT:R5 (0-success, 1-fail/overflow)
;R3: STACK_END R4: STACK_TOP
;
PUSH	
	ST R3, PUSH_SaveR3	;save R3
	ST R4, PUSH_SaveR4	;save R4
	AND R5, R5, #0		;
	LD R3, STACK_END	;
	LD R4, STACK_TOP	;
	ADD R3, R3, #-1		;
	NOT R3, R3		;
	ADD R3, R3, #1		;
	ADD R3, R3, R4		;
	BRz OVERFLOW		;stack is full
	STR R0, R4, #0		;no overflow, store value in the stack
	ADD R4, R4, #-1		;move top of the stack
	ST R4, STACK_TOP	;store top of stack pointer
	BRnzp DONE_PUSH		;
OVERFLOW
	ADD R5, R5, #1		;
DONE_PUSH
	LD R3, PUSH_SaveR3	;
	LD R4, PUSH_SaveR4	;
	RET


PUSH_SaveR3	.BLKW #1	;
PUSH_SaveR4	.BLKW #1	;


;OUT: R0, OUT R5 (0-success, 1-fail/underflow)
;R3 STACK_START R4 STACK_TOP
;
POP	
	ST R3, POP_SaveR3	;save R3
	ST R4, POP_SaveR4	;save R3
	AND R5, R5, #0		;clear R5
	LD R3, STACK_START	;
	LD R4, STACK_TOP	;
	NOT R3, R3		;
	ADD R3, R3, #1		;
	ADD R3, R3, R4		;
	BRz UNDERFLOW		;
	ADD R4, R4, #1		;
	LDR R0, R4, #0		;
	ST R4, STACK_TOP	;
	BRnzp DONE_POP		;
UNDERFLOW
	ADD R5, R5, #1		;
DONE_POP
	LD R3, POP_SaveR3	;
	LD R4, POP_SaveR4	;
	RET


POP_SaveR3	.BLKW #1	;
POP_SaveR4	.BLKW #1	;
STACK_END	.FILL x3FF0	;
STACK_START	.FILL x4000	;
STACK_TOP	.FILL x4000	;


.END